**DFS ( Depth First Search, 깊이 우선탐색)**  
  - 그래프 전체를 탐색하는 방법으로, 시작점 부터 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색
  - 스택이나 재귀함수를 통해서 구현(노드를 방문시 방문 여부를 반드시 검사-> 구현 시 루프 방지)
  - 깊이 제한(depth bound)을 사용, 다음 분기로 넘어가기위해 부모로 돌아오는것을 `백트래킹` 이라고 함

- `장단점`
  - `장점`
      - 공간복잡도가 적음(경로상의 노드만 기억)
      - 목표노드의 깊이가 깊은경우 기댓값이 높음(빠름)
      - 구현이 쉬움
  - `단점`
      - 너비 우선 탐색(BFS) 보다 느림(검색속도)
      - 목표에 이르는 경로가 다수일 경우 최적을 보장하지 않음(최단경로가 아닐 수 있음)
       
- `복잡도`
  - `시간복잡도`
      - 인접 리스트로 표현된 그래프: O(N+E)
      - 인접 행렬로 표현된 그래프: O(N^2)
      - 희소 그래프(Sparse Graph,적은 간선) 인접 리스트를 사용하는 것이 유리

---------------------------------------

**BFS ( Breadth-First Search, 넓이 우선탐색)**  
  - 루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법
  - 거리에 따라 단계적으로 (넓게(wide) 탐색) 
  - 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때
  - 큐로 반복적 구현(재귀X), 선입선출

- `장단점`
  - `장점`
      - 출발노드에서 목표노드까지의 최단 길이 경로를 보장

  - `단점`
      - DFS보다 느림
      - 경로가 매우 길 경우에는 탐색 가지가 급격히 증가함에 따라 보다 많은 기억 공간을 필요
      - 해가 존재하지 않는다면 유한 그래프(finite graph)의 경우에는 모든 그래프를 탐색한 후에 실패
      - 무한 그래프(infinite graph)의 경우에는 결코 해를 찾지도 못하고, 끝내지도 못한다
       
- `복잡도`
  - `시간복잡도`
      - 인접 리스트로 표현된 그래프: O(N+E)
      - 인접 행렬로 표현된 그래프: O(N^2)
      - 희소 그래프(Sparse Graph,적은 간선) 인접 리스트를 사용하는 것이 유리

---------------------------------------

**유형/응용 비교**  
  - 그래프의 모든 정점을 방문하는 것이 주요한 경우(둘 중 편한 것)
  - 경로의 특징을 저장해둬야 하는 경우 -> 각각의 경로마다 특징을 저장해둬야 할 때는 DFS를 사용
  - 최단거리 구해야 하는 경우(미로 등) ->  BFS가 유리, DFS는 여러해가 존재할 때 최적을 보장하지 않음
  - 검색 대상 그래프가 정말 크다면 DFS, 검색대상의 규모가 크지 않고, 검색 시작 지점으로부터 원하는 대상이 별로 멀지 않다면 BFS

---------------------------------------
### `참조`
 - [DFS](https://gmlwjd9405.github.io/2018/08/14/algorithm-dfs.html)
 - [DFS-나무위키](https://ko.wikipedia.org/wiki/%EA%B9%8A%EC%9D%B4_%EC%9A%B0%EC%84%A0_%ED%83%90%EC%83%89)
 - [BFS](https://gmlwjd9405.github.io/2018/08/15/algorithm-bfs.html)
 - [BFS-나무위키](https://ko.wikipedia.org/wiki/%EB%84%88%EB%B9%84_%EC%9A%B0%EC%84%A0_%ED%83%90%EC%83%89)
 - [비교](https://velog.io/@lucky-korma/DFS-BFS%EC%9D%98-%EC%84%A4%EB%AA%85-%EC%B0%A8%EC%9D%B4%EC%A0%90)

